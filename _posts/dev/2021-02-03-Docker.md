---
title: Container_Docker
categories: [dev]
comments: true
---

# Docker

두번째 `Gombang` project를 통해 API를 제작하면서, `Container`라는 개념을 접하게 되었고, 가장 많이 활용되고 있는 `Docker`를 통해 경험해 보고자 프로젝트에 적용하며 배우고 있다.

### 이전 포스트 Restful Note

[https://www.notion.so/haena3230/Restful-API-fad5ff16755b4170aaad26e27b3f9e22](https://www.notion.so/haena3230/Restful-API-fad5ff16755b4170aaad26e27b3f9e22)

### 배경

- 소프트웨어를 한 `컴퓨팅 환경`에서 다른 컴퓨팅 환경으로 이동하면서 환경마다 네트워크 기술과 보안 정책, 스토리지가 제각각이기 때문에 안정적이지 못했다.

→ 애플리케이션과 그 실행에 필요한 라이브러리, 바이너리, 구성 파일 등을 패키지로 묶어 배포

- 노트북-테스트 환경-실제 운영환경으로 바뀌어도 실행에 필요한 파일이 함께 따라다니므로 오류를 최소화할 수 있다.
- 운영체제를 제외하고 애플리케이션 실행에 필요한 모든 파일을 `패키징`한다는 점에서 운영체제 위에서 구현된 가상화, 즉 `운영체제 레벨 가상화` 라고 부르기도 한다.

### 서버 가상화 기술과 컨테이너

- 컨테이너에는 운영체제가 포함되지 않아 크기가 수십 MB로 작다. 반면 VM에는 운영체제가 포함되므로 보통 수 GB에 달한다.
- 결국, 컨테이너는 서버 1대에서 실행할 수 있는 개수가 VM보다 최대 10배 이상 많고, 운영체제 부팅이 필요 없어 불과 수초 만에 서비스를 시작할 수 있다.

### 특징

- **`일관성` 있는 환경**

개발자는 컨테이너를 이용해, 다른 애플리케이션과 분리된 예측 가능한 환경을 생성할 수 있습니다. 컨테이너는 애플리케이션에 필요한 소프트웨어 종속 항목(프로그래밍 언어 런타임 및 기타 소프트웨어 라이브러리의 특정 버전 등)도 포함할 수 있습니다. 개발자의 관점에서 이 모든 요소는 애플리케이션이 배포되는 최종 위치에 관계없이 항상 일관성이 있습니다. 그 결과 자연히 생산성이 향상될 수밖에 없습니다. 개발자와 IT 운영팀이 버그를 잡고 환경 차이를 진단하던 시간을 줄이고 사용자에게 신규 기능을 제공하는 데 집중할 수 있기 때문입니다. 또한 개발자가 개발 및 테스트 환경에서 세운 가정이 프로덕션 환경에서 그대로 실현될 것이기 때문에 버그 수 자체도 감소합니다.

- **폭넓은 구동 환경**

컨테이너는 Linux, Windows, Mac 운영체제, 가상 머신, 베어메탈, 개발자의 컴퓨터, 데이터 센터, 온프레미스 환경, 퍼블릭 클라우드 등 사실상 어느 환경에서나 구동되므로 개발 및 배포가 크게 쉬워집니다. 컨테이너용 [Docker 이미지 형식](https://cloud.google.com/container-registry/docs/ui?hl=ko-KRLTE)은 워낙 널리 사용되기 때문에 이동성도 매우 뛰어납니다. 소프트웨어 구동 환경이 무엇이든 컨테이너를 사용할 수 있습니다.

- **격리**

컨테이너는 CPU, 메모리, 스토리지, 네트워크 리소스를 OS 수준에서 가상화하여 개발자에게 기타 애플리케이션으로부터 논리적으로 격리된 OS 샌드박스 환경을 제공합니다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74b012f5-f820-4428-82db-81c27d5b1d06/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74b012f5-f820-4428-82db-81c27d5b1d06/Untitled.png)

### Docker

- Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼이다.
- Docker는 소프트웨어를 컨테이너라는 표준화된 유닛으로 `패키징`하며, 이 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든 것이 포함되어 있다.
- Docker를 사용하면 환경에 구애받지 않고 애플리케이션을 신속하게 배포 및 확장할 수 있으며 코드가 문제없이 실행될 것임을 확신할 수 있다.

도커 패키지는 원래 docker-engine 하나였습니다만 현재는 `docker-ce`와 `docker-ce-cli` 두 가지로 나눠져 있습니다. 여기서 ce는 커뮤니티 에디선Community Edition의 줄임말입니다. 패키지가 나눠져있는 이유를 이해하려면 도커의 아키텍처에 대해서 알아야 합니다. 도커는 크게 도커 `엔진`과 `클라이언트`로 나뉩니다. 도커 엔진은 `서버`로 동작하며, 시스템 상에 서비스로 등록 됩니다. 도커 클라이언트는 사용자가 입력하는 docker `명령어`입니다. 이 명령어를 실행하면 클라이언트는 도커 서버에 명령을 전달하고, 명령은 전적으로 서버에서 처리됩니다. 도커 클라이언트로 외부의 도커 서버에 명령을 내리는 것도 가능합니다. 이러한 아키텍처를 반영해 도커 엔진과 도커 클라이언트 패키지가 나눠졌습니다.

## **Image**

- container image, 줄여서 이미지(image)는 애플리케이션 코드 뿐만 아니라 애플리케이션 실행에 필요한 최소한의 환경(언어 런타임, 라이브러리 패키지 등)을 포함하고 있는 `바이너리(binary) 파일`하이다.
- 나의 image로 부터 동일한 container를 계속해서 만들어낼 수 있으며, 동시에 여러 개의 container를 띄울 수도 있어서 `확장성`(scalability)이 좋다.
- 이러한 image는 [Docker Hub](https://hub.docker.com/)와 같은 네트워크 상의 Docker registry통해 손쉽게 공유할 수 있기 때문에 `이식성`(portability)도 매우 뛰어나다.
- 즉, 어떤 컴퓨터에서든지 Docker만 깔려 있다면 이 image를 내려받아 contianer로 구동하면 동일하게 작동하는 애플리케이션을 얻을 수 있다.

### Volume

`Mysql` image를 docker로 실행할때, 이전 실행시 가지고 있던 정보를 유지하려면, `docker volume`을 사용하여 로컬에 저장해야 한다.

- 암시적인 volume

`container` 생성시 암시적인 volume이 생성되어 저장되고, 다음의 명령어로 확인 가능하다. 하지만 container의 생성/ 소멸과 함께 사라진다.

```jsx
docker volume ls
```

- 명시적인 volume

container 의 생성/소멸과 별도로 항상 `영구적인` 데이터를 저장하기 위해서는 container 생성시 암시적으로 생성되도록 하지 않고, 우리가 명시적으로 volume 을 만들어 사용한다. 이렇게 생성된 volume은 container 가 제거된 다음에도 계속 남아 있다.

```jsx
docker volume create [volume Name]
```

이렇게 생성된 이름있는 volume은 다음과 같이 실행하여, docker image에 정의된 volume의 `mount directory`에 연결할 수 있다.

```jsx
docker run --rm -d --name testdb -e MYSQL_ROOT_PASSWORD=mirero -v testdb-volume:/var/lib/mysql mysql
3fd2a5beb9a2de76fcfbae72b70bc57818f5c8bdec99635ae9680eca23565429
```

- volume 파일 내용 확인

volume의 파일 내용을 보고 싶다면, 임의 컨테이너에 `mount` 해서 볼수 있고, 이러한 특징으로 파일 내역을 `압축`하여 다른 사람과 `공유`하는 것도 가능하다.

- 특정 Container에 Mount되어있는 Volume확인

```jsx
docker inspect {container id or Name]
```

### Docker 명령어

- 이미지 가져오기

```jsx
docker pull [image]
```

- 신규 Container 생성

```jsx
docker run --name mysql-container -e MYSQL_ROOT_PASSWORD=[password] -d -p 3306:3306 [mysql]
```

- Images 확인

```jsx
docker images
```

- container 상태 확인

```jsx
docker ps
docker ps -a // 종료된 컨테이너 확인
```

- 종료된 Container 실행

```jsx
docker start [container name or id]
```

- 실행중인 컨테이너 커맨드라인으로 진입

```jsx
docker exec [-option] [container_id or name] /bin/bash
docker exec -it [container_id or name] /bin/bash
```

- 컨테이너 빠져나오기

```jsx
exit;
```

- 컨테이너 low level 정보 가져오기

```jsx
docker inspect [container_id]
```

- mysql 시작

```jsx
mysql -u root -p // password 9863
```

### Docker network

docker 의 MySQL image를 연동하기 위해 `host` 정보가 필요했고, 이는 `docker OS`의 `host IP`가 되기 때문에 docker에서 가상환경의 IP를 알아야 한다.

- 네트워크 찾기

```jsx
docker network ls
```

- [네트워크]를 사용하는 모든 컨테이너의 IP 찾기

```jsx
Docker network inspect [network Name] -f "{{ json .Containers }}"
```

### Docker Composer

docker의 container를 두개 이상 구동할 수 있게 도와주는 툴이다. `docker-compse.yml` 파일을 통해 container들을 어떻게 빌드하고 구동할지를 정의할 수 있다.
