---
title: Hash
categories: [algorithm]
comments: true
---

- 데이터를 저장할 위치를 간단한 연산으로 구하는 것입니다.
- 검색과 더불어 추가, 삭제도 효율적으로 수행할 수 있습니다.

### 정렬된 배열에 새로운 값 추가하기

1. 삽입할 위치를 이진검색법으로 조사
2. 위치 이후의 요소를 하나씩 뒤로 이동
3. 대입
4. O(n)

### 해시법

1. 해시함수 : ex 배열의 키 값을 배열의 요소수로 나눈 나머지 → 해시값
2. 해시값이 인덱스가 되도록 배열 생성(버킷)

→ 추가하거나 삭제할 때 배열 요소의 이동이 없음

### 충돌

해시 값이 1:1이라는 보증이 없음(버킷이 이미 채워져 있을 수 있음)

→ 해시 함수는 해시값이 고르게 분포하도록 만들어야합니다.

### 충동대처1 - 체인법(열린 해시법)

같은 해시값을 갖는 요소를 연결 리스트로 관리합니다.

- 버킷용 클래스 Node<K,V>
  - key : 키값
  - data : 데이터
  - next : 다음 노드에 대한 참조
- 해시클래스 ChainHash<K,V>

  - size : 해시테이블 크기
  - table : 해시테이블 저장하는 배열

- 검색
  - 해시값으로 버킷 찾기 → null 이면 실패 / 있으면 연결리스트 스캔하기
- 삽입
  - 해시값을 통해 버킷을 찾는다
  - 노드를 새로 만든다.
  - 리스트의 맨 앞에 삽입하고 next 가 원래 있던 요소를 참조하도록 업데이트
- 삭제
  - 검색해서 삭제 후 next 참조가 있다면 업데이트

### 충돌대처2 - 오픈 주소법(닫힌 해시법)

- 삽입
  - 빈 버킷을 찾을 때 까지 해시를 반복 → 선형 탐사법
- 삭제
  - 인덱스가 비어있지만 재해시를 통해 다른 곳에 저장되어 있을 수 있음 → 버킷에 속성 부여
  1. 데이터 저장 속성값
  2. 비어있음 속성값
  3. 삭제마침 속성값 (충돌이 있었던 요소 있으니 다시 검색)
- 검색
  - 비어있음 속성 → 실패
  - 삭제마침 → 재해시를 통해 다시 검색
